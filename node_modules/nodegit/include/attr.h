// This is a generated file, modify: generate/templates/templates/class_header.h

#ifndef GITATTR_H
#define GITATTR_H
#include <nan.h>
#include <string>
#include <utility>
#include <algorithm>
#include <set>
#include <unordered_set>
#include <sstream>

#include "async_baton.h"
#include "async_worker.h"
#include "cleanup_handle.h"
#include "context.h"
#include "lock_master.h"
#include "nodegit_wrapper.h"
#include "promise_completion.h"
#include "reference_counter.h"
#include "worker_pool.h"

extern "C" {
#include <git2.h>
}

#include "../include/typedefs.h"

#include "../include/repository.h"
#include "../include/attr_options.h"

using namespace node;
using namespace v8;


class GitAttr : public
  Nan::ObjectWrap
{
   public:
    GitAttr(const GitAttr &) = delete;
    GitAttr(GitAttr &&) = delete;
    GitAttr &operator=(const GitAttr &) = delete;
    GitAttr &operator=(GitAttr &&) = delete;

    static void InitializeComponent (v8::Local<v8::Object> target, nodegit::Context *nodegitContext);

               static int ForeachExt_callback_cppCallback (
      const char * name
      ,
       const char * value
      ,
       void * payload
      );

    static void ForeachExt_callback_cancelAsync(void *baton);
    static void ForeachExt_callback_async(void *baton);
    static void ForeachExt_callback_promiseCompleted(bool isFulfilled, nodegit::AsyncBaton *_baton, v8::Local<v8::Value> result);
    class ForeachExt_CallbackBaton : public nodegit::AsyncBatonWithResult<int> {
    public:
      const char * name;
      const char * value;
      void * payload;
 

      ForeachExt_CallbackBaton(const int &defaultResult)
        : nodegit::AsyncBatonWithResult<int>(defaultResult) {
        }
    };
                                      

  private:

    static NAN_METHOD(AddMacro);

    static NAN_METHOD(CacheFlush);

    struct ForeachExtBaton {
      int error_code;
      const git_error* error;
      git_repository * repo;
      git_attr_options * opts;
      const char * path;
      git_attr_foreach_cb callback;
      void * payload;
        int result;
     };
    class ForeachExtWorker : public nodegit::AsyncWorker {
      public:
        ForeachExtWorker(
            ForeachExtBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitAttr:ForeachExt", cleanupHandles)
          , baton(_baton) {};
        ForeachExtWorker(const ForeachExtWorker &) = delete;
        ForeachExtWorker(ForeachExtWorker &&) = delete;
        ForeachExtWorker &operator=(const ForeachExtWorker &) = delete;
        ForeachExtWorker &operator=(ForeachExtWorker &&) = delete;
        ~ForeachExtWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        ForeachExtBaton *baton;
    };

    static NAN_METHOD(ForeachExt);

    struct GetBaton {
      int error_code;
      const git_error* error;
      const char * value_out;
      git_repository * repo;
      uint32_t flags;
      const char * path;
      const char * name;
     };
    class GetWorker : public nodegit::AsyncWorker {
      public:
        GetWorker(
            GetBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitAttr:Get", cleanupHandles)
          , baton(_baton) {};
        GetWorker(const GetWorker &) = delete;
        GetWorker(GetWorker &&) = delete;
        GetWorker &operator=(const GetWorker &) = delete;
        GetWorker &operator=(GetWorker &&) = delete;
        ~GetWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        GetBaton *baton;
    };

    static NAN_METHOD(Get);

    static NAN_METHOD(GetExt);

    struct GetManyBaton {
      int error_code;
      const git_error* error;
      const char * values_out;
      git_repository * repo;
      uint32_t flags;
      const char * path;
      size_t num_attr;
      const char ** names;
     };
    class GetManyWorker : public nodegit::AsyncWorker {
      public:
        GetManyWorker(
            GetManyBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitAttr:GetMany", cleanupHandles)
          , baton(_baton) {};
        GetManyWorker(const GetManyWorker &) = delete;
        GetManyWorker(GetManyWorker &&) = delete;
        GetManyWorker &operator=(const GetManyWorker &) = delete;
        GetManyWorker &operator=(GetManyWorker &&) = delete;
        ~GetManyWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        GetManyBaton *baton;
    };

    static NAN_METHOD(GetMany);

    static NAN_METHOD(GetManyExt);

    static NAN_METHOD(Value);

    struct ForeachExt_globalPayload {
      Nan::Callback * callback;

      ForeachExt_globalPayload() {
        callback = NULL;
      }

      ForeachExt_globalPayload(const ForeachExt_globalPayload &) = delete;
      ForeachExt_globalPayload(ForeachExt_globalPayload &&) = delete;
      ForeachExt_globalPayload &operator=(const ForeachExt_globalPayload &) = delete;
      ForeachExt_globalPayload &operator=(ForeachExt_globalPayload &&) = delete;

      ~ForeachExt_globalPayload() {
        if (callback != NULL) {
          delete callback;
        }
      }
    };
};

#endif
