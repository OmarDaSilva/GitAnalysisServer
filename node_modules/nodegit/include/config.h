// This is a generated file, modify: generate/templates/templates/class_header.h

#ifndef GITCONFIG_H
#define GITCONFIG_H
#include <nan.h>
#include <string>
#include <utility>
#include <algorithm>
#include <set>
#include <unordered_set>
#include <sstream>

#include "async_baton.h"
#include "async_worker.h"
#include "cleanup_handle.h"
#include "context.h"
#include "lock_master.h"
#include "nodegit_wrapper.h"
#include "promise_completion.h"
#include "reference_counter.h"
#include "worker_pool.h"

extern "C" {
#include <git2.h>
}

#include "../include/typedefs.h"

#include "../include/git_buf_converter.h"
#include "../include/buf.h"
#include "../include/config_entry.h"
#include "../include/transaction.h"
// Forward declaration.
struct git_config {
};

using namespace node;
using namespace v8;

class GitConfig;
 
struct GitConfigTraits {
  typedef GitConfig cppClass;
  typedef git_config cType;
 
  static const bool isDuplicable = false;
  static void duplicate(git_config **dest, git_config *src) {
     Nan::ThrowError("duplicate called on GitConfig which cannot be duplicated");
   }

  static std::string className() { return "GitConfig"; };
  static const bool isSingleton = false;
  static const bool isFreeable = true;
  static void free(git_config *raw) {
    unsigned long referenceCount = 0;
     if (referenceCount == 0) {
      ::git_config_free(raw); // :: to avoid calling this free recursively
    }
   }
};

class GitConfig : public
  NodeGitWrapper<GitConfigTraits>
{
    // grant full access to base class
    friend class NodeGitWrapper<GitConfigTraits>;
   public:
    GitConfig(const GitConfig &) = delete;
    GitConfig(GitConfig &&) = delete;
    GitConfig &operator=(const GitConfig &) = delete;
    GitConfig &operator=(GitConfig &&) = delete;

    static void InitializeComponent (v8::Local<v8::Object> target, nodegit::Context *nodegitContext);

                                                                                             

  private:
    GitConfig()
      : NodeGitWrapper<GitConfigTraits>(
           "A new GitConfig cannot be instantiated."
       )
    {}
    GitConfig(git_config *raw, bool selfFreeing, v8::Local<v8::Object> owner = v8::Local<v8::Object>())
      : NodeGitWrapper<GitConfigTraits>(raw, selfFreeing, owner)
    {}
    ~GitConfig();

    static NAN_METHOD(DeleteEntry);

    static NAN_METHOD(DeleteMultivar);

    struct FindGlobalBaton {
      int error_code;
      const git_error* error;
      git_buf * out;
     };
    class FindGlobalWorker : public nodegit::AsyncWorker {
      public:
        FindGlobalWorker(
            FindGlobalBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:FindGlobal", cleanupHandles)
          , baton(_baton) {};
        FindGlobalWorker(const FindGlobalWorker &) = delete;
        FindGlobalWorker(FindGlobalWorker &&) = delete;
        FindGlobalWorker &operator=(const FindGlobalWorker &) = delete;
        FindGlobalWorker &operator=(FindGlobalWorker &&) = delete;
        ~FindGlobalWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        FindGlobalBaton *baton;
    };

    static NAN_METHOD(FindGlobal);

    struct FindProgramdataBaton {
      int error_code;
      const git_error* error;
      git_buf * out;
     };
    class FindProgramdataWorker : public nodegit::AsyncWorker {
      public:
        FindProgramdataWorker(
            FindProgramdataBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:FindProgramdata", cleanupHandles)
          , baton(_baton) {};
        FindProgramdataWorker(const FindProgramdataWorker &) = delete;
        FindProgramdataWorker(FindProgramdataWorker &&) = delete;
        FindProgramdataWorker &operator=(const FindProgramdataWorker &) = delete;
        FindProgramdataWorker &operator=(FindProgramdataWorker &&) = delete;
        ~FindProgramdataWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        FindProgramdataBaton *baton;
    };

    static NAN_METHOD(FindProgramdata);

    struct FindSystemBaton {
      int error_code;
      const git_error* error;
      git_buf * out;
     };
    class FindSystemWorker : public nodegit::AsyncWorker {
      public:
        FindSystemWorker(
            FindSystemBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:FindSystem", cleanupHandles)
          , baton(_baton) {};
        FindSystemWorker(const FindSystemWorker &) = delete;
        FindSystemWorker(FindSystemWorker &&) = delete;
        FindSystemWorker &operator=(const FindSystemWorker &) = delete;
        FindSystemWorker &operator=(FindSystemWorker &&) = delete;
        ~FindSystemWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        FindSystemBaton *baton;
    };

    static NAN_METHOD(FindSystem);

    struct FindXdgBaton {
      int error_code;
      const git_error* error;
      git_buf * out;
     };
    class FindXdgWorker : public nodegit::AsyncWorker {
      public:
        FindXdgWorker(
            FindXdgBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:FindXdg", cleanupHandles)
          , baton(_baton) {};
        FindXdgWorker(const FindXdgWorker &) = delete;
        FindXdgWorker(FindXdgWorker &&) = delete;
        FindXdgWorker &operator=(const FindXdgWorker &) = delete;
        FindXdgWorker &operator=(FindXdgWorker &&) = delete;
        ~FindXdgWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        FindXdgBaton *baton;
    };

    static NAN_METHOD(FindXdg);

    struct GetBoolBaton {
      int error_code;
      const git_error* error;
      int * out;
      const git_config * cfg;
      const char * name;
     };
    class GetBoolWorker : public nodegit::AsyncWorker {
      public:
        GetBoolWorker(
            GetBoolBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:GetBool", cleanupHandles)
          , baton(_baton) {};
        GetBoolWorker(const GetBoolWorker &) = delete;
        GetBoolWorker(GetBoolWorker &&) = delete;
        GetBoolWorker &operator=(const GetBoolWorker &) = delete;
        GetBoolWorker &operator=(GetBoolWorker &&) = delete;
        ~GetBoolWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        GetBoolBaton *baton;
    };

    static NAN_METHOD(GetBool);

    struct GetEntryBaton {
      int error_code;
      const git_error* error;
      git_config_entry * out;
      const git_config * cfg;
      const char * name;
     };
    class GetEntryWorker : public nodegit::AsyncWorker {
      public:
        GetEntryWorker(
            GetEntryBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:GetEntry", cleanupHandles)
          , baton(_baton) {};
        GetEntryWorker(const GetEntryWorker &) = delete;
        GetEntryWorker(GetEntryWorker &&) = delete;
        GetEntryWorker &operator=(const GetEntryWorker &) = delete;
        GetEntryWorker &operator=(GetEntryWorker &&) = delete;
        ~GetEntryWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        GetEntryBaton *baton;
    };

    static NAN_METHOD(GetEntry);

    struct GetInt32Baton {
      int error_code;
      const git_error* error;
      int32_t * out;
      const git_config * cfg;
      const char * name;
     };
    class GetInt32Worker : public nodegit::AsyncWorker {
      public:
        GetInt32Worker(
            GetInt32Baton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:GetInt32", cleanupHandles)
          , baton(_baton) {};
        GetInt32Worker(const GetInt32Worker &) = delete;
        GetInt32Worker(GetInt32Worker &&) = delete;
        GetInt32Worker &operator=(const GetInt32Worker &) = delete;
        GetInt32Worker &operator=(GetInt32Worker &&) = delete;
        ~GetInt32Worker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        GetInt32Baton *baton;
    };

    static NAN_METHOD(GetInt32);

    struct GetInt64Baton {
      int error_code;
      const git_error* error;
      int64_t * out;
      const git_config * cfg;
      const char * name;
     };
    class GetInt64Worker : public nodegit::AsyncWorker {
      public:
        GetInt64Worker(
            GetInt64Baton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:GetInt64", cleanupHandles)
          , baton(_baton) {};
        GetInt64Worker(const GetInt64Worker &) = delete;
        GetInt64Worker(GetInt64Worker &&) = delete;
        GetInt64Worker &operator=(const GetInt64Worker &) = delete;
        GetInt64Worker &operator=(GetInt64Worker &&) = delete;
        ~GetInt64Worker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        GetInt64Baton *baton;
    };

    static NAN_METHOD(GetInt64);

    struct GetPathBaton {
      int error_code;
      const git_error* error;
      git_buf * out;
      const git_config * cfg;
      const char * name;
     };
    class GetPathWorker : public nodegit::AsyncWorker {
      public:
        GetPathWorker(
            GetPathBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:GetPath", cleanupHandles)
          , baton(_baton) {};
        GetPathWorker(const GetPathWorker &) = delete;
        GetPathWorker(GetPathWorker &&) = delete;
        GetPathWorker &operator=(const GetPathWorker &) = delete;
        GetPathWorker &operator=(GetPathWorker &&) = delete;
        ~GetPathWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        GetPathBaton *baton;
    };

    static NAN_METHOD(GetPath);

    struct GetStringBufBaton {
      int error_code;
      const git_error* error;
      git_buf * out;
      const git_config * cfg;
      const char * name;
     };
    class GetStringBufWorker : public nodegit::AsyncWorker {
      public:
        GetStringBufWorker(
            GetStringBufBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:GetStringBuf", cleanupHandles)
          , baton(_baton) {};
        GetStringBufWorker(const GetStringBufWorker &) = delete;
        GetStringBufWorker(GetStringBufWorker &&) = delete;
        GetStringBufWorker &operator=(const GetStringBufWorker &) = delete;
        GetStringBufWorker &operator=(GetStringBufWorker &&) = delete;
        ~GetStringBufWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        GetStringBufBaton *baton;
    };

    static NAN_METHOD(GetStringBuf);

    struct LockBaton {
      int error_code;
      const git_error* error;
      git_transaction * tx;
      git_config * cfg;
     };
    class LockWorker : public nodegit::AsyncWorker {
      public:
        LockWorker(
            LockBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:Lock", cleanupHandles)
          , baton(_baton) {};
        LockWorker(const LockWorker &) = delete;
        LockWorker(LockWorker &&) = delete;
        LockWorker &operator=(const LockWorker &) = delete;
        LockWorker &operator=(LockWorker &&) = delete;
        ~LockWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        LockBaton *baton;
    };

    static NAN_METHOD(Lock);

    struct OpenDefaultBaton {
      int error_code;
      const git_error* error;
      git_config * out;
     };
    class OpenDefaultWorker : public nodegit::AsyncWorker {
      public:
        OpenDefaultWorker(
            OpenDefaultBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:OpenDefault", cleanupHandles)
          , baton(_baton) {};
        OpenDefaultWorker(const OpenDefaultWorker &) = delete;
        OpenDefaultWorker(OpenDefaultWorker &&) = delete;
        OpenDefaultWorker &operator=(const OpenDefaultWorker &) = delete;
        OpenDefaultWorker &operator=(OpenDefaultWorker &&) = delete;
        ~OpenDefaultWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        OpenDefaultBaton *baton;
    };

    static NAN_METHOD(OpenDefault);

    struct OpenOndiskBaton {
      int error_code;
      const git_error* error;
      git_config * out;
      const char * path;
     };
    class OpenOndiskWorker : public nodegit::AsyncWorker {
      public:
        OpenOndiskWorker(
            OpenOndiskBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:OpenOndisk", cleanupHandles)
          , baton(_baton) {};
        OpenOndiskWorker(const OpenOndiskWorker &) = delete;
        OpenOndiskWorker(OpenOndiskWorker &&) = delete;
        OpenOndiskWorker &operator=(const OpenOndiskWorker &) = delete;
        OpenOndiskWorker &operator=(OpenOndiskWorker &&) = delete;
        ~OpenOndiskWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        OpenOndiskBaton *baton;
    };

    static NAN_METHOD(OpenOndisk);

    struct SetBoolBaton {
      int error_code;
      const git_error* error;
      git_config * cfg;
      const char * name;
      int value;
     };
    class SetBoolWorker : public nodegit::AsyncWorker {
      public:
        SetBoolWorker(
            SetBoolBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:SetBool", cleanupHandles)
          , baton(_baton) {};
        SetBoolWorker(const SetBoolWorker &) = delete;
        SetBoolWorker(SetBoolWorker &&) = delete;
        SetBoolWorker &operator=(const SetBoolWorker &) = delete;
        SetBoolWorker &operator=(SetBoolWorker &&) = delete;
        ~SetBoolWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        SetBoolBaton *baton;
    };

    static NAN_METHOD(SetBool);

    struct SetInt32Baton {
      int error_code;
      const git_error* error;
      git_config * cfg;
      const char * name;
      int32_t value;
     };
    class SetInt32Worker : public nodegit::AsyncWorker {
      public:
        SetInt32Worker(
            SetInt32Baton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:SetInt32", cleanupHandles)
          , baton(_baton) {};
        SetInt32Worker(const SetInt32Worker &) = delete;
        SetInt32Worker(SetInt32Worker &&) = delete;
        SetInt32Worker &operator=(const SetInt32Worker &) = delete;
        SetInt32Worker &operator=(SetInt32Worker &&) = delete;
        ~SetInt32Worker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        SetInt32Baton *baton;
    };

    static NAN_METHOD(SetInt32);

    struct SetInt64Baton {
      int error_code;
      const git_error* error;
      git_config * cfg;
      const char * name;
      int64_t value;
     };
    class SetInt64Worker : public nodegit::AsyncWorker {
      public:
        SetInt64Worker(
            SetInt64Baton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:SetInt64", cleanupHandles)
          , baton(_baton) {};
        SetInt64Worker(const SetInt64Worker &) = delete;
        SetInt64Worker(SetInt64Worker &&) = delete;
        SetInt64Worker &operator=(const SetInt64Worker &) = delete;
        SetInt64Worker &operator=(SetInt64Worker &&) = delete;
        ~SetInt64Worker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        SetInt64Baton *baton;
    };

    static NAN_METHOD(SetInt64);

    struct SetMultivarBaton {
      int error_code;
      const git_error* error;
      git_config * cfg;
      const char * name;
      const char * regexp;
      const char * value;
     };
    class SetMultivarWorker : public nodegit::AsyncWorker {
      public:
        SetMultivarWorker(
            SetMultivarBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:SetMultivar", cleanupHandles)
          , baton(_baton) {};
        SetMultivarWorker(const SetMultivarWorker &) = delete;
        SetMultivarWorker(SetMultivarWorker &&) = delete;
        SetMultivarWorker &operator=(const SetMultivarWorker &) = delete;
        SetMultivarWorker &operator=(SetMultivarWorker &&) = delete;
        ~SetMultivarWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        SetMultivarBaton *baton;
    };

    static NAN_METHOD(SetMultivar);

    struct SetStringBaton {
      int error_code;
      const git_error* error;
      git_config * cfg;
      const char * name;
      const char * value;
     };
    class SetStringWorker : public nodegit::AsyncWorker {
      public:
        SetStringWorker(
            SetStringBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:SetString", cleanupHandles)
          , baton(_baton) {};
        SetStringWorker(const SetStringWorker &) = delete;
        SetStringWorker(SetStringWorker &&) = delete;
        SetStringWorker &operator=(const SetStringWorker &) = delete;
        SetStringWorker &operator=(SetStringWorker &&) = delete;
        ~SetStringWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        SetStringBaton *baton;
    };

    static NAN_METHOD(SetString);

    struct SnapshotBaton {
      int error_code;
      const git_error* error;
      git_config * out;
      git_config * config;
     };
    class SnapshotWorker : public nodegit::AsyncWorker {
      public:
        SnapshotWorker(
            SnapshotBaton *_baton,
            Nan::Callback *callback,
            std::map<std::string, std::shared_ptr<nodegit::CleanupHandle>> &cleanupHandles
        ) : nodegit::AsyncWorker(callback, "nodegit:AsyncWorker:GitConfig:Snapshot", cleanupHandles)
          , baton(_baton) {};
        SnapshotWorker(const SnapshotWorker &) = delete;
        SnapshotWorker(SnapshotWorker &&) = delete;
        SnapshotWorker &operator=(const SnapshotWorker &) = delete;
        SnapshotWorker &operator=(SnapshotWorker &&) = delete;
        ~SnapshotWorker() {};
        void Execute();
        void HandleErrorCallback();
        void HandleOKCallback();
        nodegit::LockMaster AcquireLocks();

      private:
        SnapshotBaton *baton;
    };

    static NAN_METHOD(Snapshot);
};

#endif
