// This is a generated file, modify: generate/templates/templates/struct_content.cc

// generated from struct_content.cc
#include <nan.h>
#include <string.h>
#ifdef WIN32
#include <windows.h>
#else
#include <unistd.h>
#endif // win32

extern "C" {
  #include <git2.h>
 }

#include <iostream>
#include "../include/nodegit.h"
#include "../include/lock_master.h"
#include "../include/functions/copy.h"
#include "../include/index_entry.h"
#include "nodegit_wrapper.cc"

  #include "../include/index_time.h"
  #include "../include/oid.h"
 
using namespace v8;
using namespace node;
using namespace std;

  GitIndexEntry::GitIndexEntry() : NodeGitWrapper<GitIndexEntryTraits>(NULL, true, v8::Local<v8::Object>())
  {
    this->raw = new git_index_entry;
 
    this->ConstructFields();
  }

  GitIndexEntry::GitIndexEntry(git_index_entry* raw, bool selfFreeing, v8::Local<v8::Object> owner)
   : NodeGitWrapper<GitIndexEntryTraits>(raw, selfFreeing, owner)
  {
    this->ConstructFields();
  }

  GitIndexEntry::~GitIndexEntry() {
            this->ctime.Reset();
               this->mtime.Reset();
                                 this->id.Reset();
               }

  void GitIndexEntry::ConstructFields() {
            v8::Local<Object> ctimeTemp = Nan::To<v8::Object>(GitIndexTime::New(
&this->raw->ctime,
              false
            )).ToLocalChecked();
            this->ctime.Reset(ctimeTemp);
               v8::Local<Object> mtimeTemp = Nan::To<v8::Object>(GitIndexTime::New(
&this->raw->mtime,
              false
            )).ToLocalChecked();
            this->mtime.Reset(mtimeTemp);
                                 v8::Local<Object> idTemp = Nan::To<v8::Object>(GitOid::New(
&this->raw->id,
              false
            )).ToLocalChecked();
            this->id.Reset(idTemp);
               }

  void GitIndexEntry::InitializeComponent(Local<Object> target, nodegit::Context *nodegitContext) {
    Nan::HandleScope scope;

    Local<External> nodegitExternal = Nan::New<External>(nodegitContext);
    Local<FunctionTemplate> tpl = Nan::New<FunctionTemplate>(JSNewFunction, nodegitExternal);

    tpl->InstanceTemplate()->SetInternalFieldCount(1);
    tpl->SetClassName(Nan::New("IndexEntry").ToLocalChecked());

        Nan::SetAccessor(tpl->InstanceTemplate(), Nan::New("ctime").ToLocalChecked(), GetCtime, SetCtime, nodegitExternal);
          Nan::SetAccessor(tpl->InstanceTemplate(), Nan::New("mtime").ToLocalChecked(), GetMtime, SetMtime, nodegitExternal);
          Nan::SetAccessor(tpl->InstanceTemplate(), Nan::New("dev").ToLocalChecked(), GetDev, SetDev, nodegitExternal);
          Nan::SetAccessor(tpl->InstanceTemplate(), Nan::New("ino").ToLocalChecked(), GetIno, SetIno, nodegitExternal);
          Nan::SetAccessor(tpl->InstanceTemplate(), Nan::New("mode").ToLocalChecked(), GetMode, SetMode, nodegitExternal);
          Nan::SetAccessor(tpl->InstanceTemplate(), Nan::New("uid").ToLocalChecked(), GetUid, SetUid, nodegitExternal);
          Nan::SetAccessor(tpl->InstanceTemplate(), Nan::New("gid").ToLocalChecked(), GetGid, SetGid, nodegitExternal);
          Nan::SetAccessor(tpl->InstanceTemplate(), Nan::New("fileSize").ToLocalChecked(), GetFileSize, SetFileSize, nodegitExternal);
          Nan::SetAccessor(tpl->InstanceTemplate(), Nan::New("id").ToLocalChecked(), GetId, SetId, nodegitExternal);
          Nan::SetAccessor(tpl->InstanceTemplate(), Nan::New("flags").ToLocalChecked(), GetFlags, SetFlags, nodegitExternal);
          Nan::SetAccessor(tpl->InstanceTemplate(), Nan::New("flagsExtended").ToLocalChecked(), GetFlagsExtended, SetFlagsExtended, nodegitExternal);
          Nan::SetAccessor(tpl->InstanceTemplate(), Nan::New("path").ToLocalChecked(), GetPath, SetPath, nodegitExternal);
   
    InitializeTemplate(tpl);

    v8::Local<Function> constructor_template = Nan::GetFunction(tpl).ToLocalChecked();
    nodegitContext->SaveToPersistent("GitIndexEntry::Template", constructor_template);
  }

    NAN_GETTER(GitIndexEntry::GetCtime) {

      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        info.GetReturnValue().Set(Nan::New(wrapper->ctime));

     }

    NAN_SETTER(GitIndexEntry::SetCtime) {
      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        v8::Local<Object> ctime(Nan::To<v8::Object>(value).ToLocalChecked());

        wrapper->ctime.Reset(ctime);

           auto wrappedObject = Nan::ObjectWrap::Unwrap<GitIndexTime>(ctime);
          wrapper->raw->ctime = * wrappedObject->GetValue();
          wrapper->AddReferenceCallbacks(
            0,
            [wrappedObject]() {
              wrappedObject->Reference();
            },
            [wrappedObject]() {
              wrappedObject->Unreference();
            }
          );
      }
     NAN_GETTER(GitIndexEntry::GetMtime) {

      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        info.GetReturnValue().Set(Nan::New(wrapper->mtime));

     }

    NAN_SETTER(GitIndexEntry::SetMtime) {
      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        v8::Local<Object> mtime(Nan::To<v8::Object>(value).ToLocalChecked());

        wrapper->mtime.Reset(mtime);

           auto wrappedObject = Nan::ObjectWrap::Unwrap<GitIndexTime>(mtime);
          wrapper->raw->mtime = * wrappedObject->GetValue();
          wrapper->AddReferenceCallbacks(
            1,
            [wrappedObject]() {
              wrappedObject->Reference();
            },
            [wrappedObject]() {
              wrappedObject->Unreference();
            }
          );
      }
     NAN_GETTER(GitIndexEntry::GetDev) {

      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        info.GetReturnValue().Set(Nan::New<Number>(wrapper->GetValue()->dev));
     }

    NAN_SETTER(GitIndexEntry::SetDev) {
      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

         if (value->IsNumber()) {
          wrapper->GetValue()->dev = (uint32_t) Nan::To<int32_t>(value).FromJust();
        }
     }
     NAN_GETTER(GitIndexEntry::GetIno) {

      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        info.GetReturnValue().Set(Nan::New<Number>(wrapper->GetValue()->ino));
     }

    NAN_SETTER(GitIndexEntry::SetIno) {
      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

         if (value->IsNumber()) {
          wrapper->GetValue()->ino = (uint32_t) Nan::To<int32_t>(value).FromJust();
        }
     }
     NAN_GETTER(GitIndexEntry::GetMode) {

      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        info.GetReturnValue().Set(Nan::New<Number>(wrapper->GetValue()->mode));
     }

    NAN_SETTER(GitIndexEntry::SetMode) {
      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

         if (value->IsNumber()) {
          wrapper->GetValue()->mode = (uint32_t) Nan::To<int32_t>(value).FromJust();
        }
     }
     NAN_GETTER(GitIndexEntry::GetUid) {

      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        info.GetReturnValue().Set(Nan::New<Number>(wrapper->GetValue()->uid));
     }

    NAN_SETTER(GitIndexEntry::SetUid) {
      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

         if (value->IsNumber()) {
          wrapper->GetValue()->uid = (uint32_t) Nan::To<int32_t>(value).FromJust();
        }
     }
     NAN_GETTER(GitIndexEntry::GetGid) {

      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        info.GetReturnValue().Set(Nan::New<Number>(wrapper->GetValue()->gid));
     }

    NAN_SETTER(GitIndexEntry::SetGid) {
      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

         if (value->IsNumber()) {
          wrapper->GetValue()->gid = (uint32_t) Nan::To<int32_t>(value).FromJust();
        }
     }
     NAN_GETTER(GitIndexEntry::GetFileSize) {

      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        info.GetReturnValue().Set(Nan::New<Number>(wrapper->GetValue()->file_size));
     }

    NAN_SETTER(GitIndexEntry::SetFileSize) {
      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

         if (value->IsNumber()) {
          wrapper->GetValue()->file_size = (uint32_t) Nan::To<int32_t>(value).FromJust();
        }
     }
     NAN_GETTER(GitIndexEntry::GetId) {

      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        info.GetReturnValue().Set(Nan::New(wrapper->id));

     }

    NAN_SETTER(GitIndexEntry::SetId) {
      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        v8::Local<Object> id(Nan::To<v8::Object>(value).ToLocalChecked());

        wrapper->id.Reset(id);

           auto wrappedObject = Nan::ObjectWrap::Unwrap<GitOid>(id);
          wrapper->raw->id = * wrappedObject->GetValue();
          wrapper->AddReferenceCallbacks(
            8,
            [wrappedObject]() {
              wrappedObject->Reference();
            },
            [wrappedObject]() {
              wrappedObject->Unreference();
            }
          );
      }
     NAN_GETTER(GitIndexEntry::GetFlags) {

      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        info.GetReturnValue().Set(Nan::New<Number>(wrapper->GetValue()->flags));
     }

    NAN_SETTER(GitIndexEntry::SetFlags) {
      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

         if (value->IsNumber()) {
          wrapper->GetValue()->flags = (uint16_t) Nan::To<int32_t>(value).FromJust();
        }
     }
     NAN_GETTER(GitIndexEntry::GetFlagsExtended) {

      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        info.GetReturnValue().Set(Nan::New<Number>(wrapper->GetValue()->flags_extended));
     }

    NAN_SETTER(GitIndexEntry::SetFlagsExtended) {
      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

         if (value->IsNumber()) {
          wrapper->GetValue()->flags_extended = (uint16_t) Nan::To<int32_t>(value).FromJust();
        }
     }
     NAN_GETTER(GitIndexEntry::GetPath) {

      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        if (wrapper->GetValue()->path) {
          info.GetReturnValue().Set(Nan::New<String>(wrapper->GetValue()->path).ToLocalChecked());
        }
        else {
          return;
        }

     }

    NAN_SETTER(GitIndexEntry::SetPath) {
      GitIndexEntry *wrapper = Nan::ObjectWrap::Unwrap<GitIndexEntry>(info.This());

        if (wrapper->GetValue()->path) {
        }

        Nan::Utf8String str(value);
        wrapper->GetValue()->path = strdup(*str);

     }
  
  // force base class template instantiation, to make sure we get all the
  // methods, statics, etc.
  template class NodeGitWrapper<GitIndexEntryTraits>;

 
ConfigurableGitIndexEntry::ConfigurableGitIndexEntry(nodegit::Context *nodegitContext)
  : nodegit::ConfigurableClassWrapper<GitIndexEntryTraits>(nodegitContext)
{
    this->raw = new git_index_entry;
 }

ConfigurableGitIndexEntry::~ConfigurableGitIndexEntry() {
                              delete this->raw->path;
   }

nodegit::ConfigurableClassWrapper<GitIndexEntryTraits>::v8ConversionResult ConfigurableGitIndexEntry::fromJavascript(nodegit::Context *nodegitContext, v8::Local<v8::Value> input) {
  if (!input->IsObject()) {
    return {
      "Must pass object for ConfigurableGitIndexEntry"
    };
  }

  Nan::HandleScope scope;
  v8::Local<v8::Object> inputObj = input.As<v8::Object>();
  std::shared_ptr<ConfigurableGitIndexEntry> output(new ConfigurableGitIndexEntry(nodegitContext));

  // unpack the data into the correct fields
        {
          v8::Local<v8::Value> maybeNestedObject = nodegit::safeGetField(inputObj, "ctime");
          if (!maybeNestedObject.IsEmpty() && !maybeNestedObject->IsUndefined() && !maybeNestedObject->IsNull()) {
            auto conversionResult = ConfigurableGitIndexTime::fromJavascript(nodegitContext, maybeNestedObject);
            if (!conversionResult.result) {
              std::string error = "Failed to set ctime: ";
              error += conversionResult.error;
              return {
                error
              };
            }

            auto child = conversionResult.result;
            output->childCleanupVector.push_back(child);
            output->raw->ctime = *child->GetValue();
          }
        }
          {
          v8::Local<v8::Value> maybeNestedObject = nodegit::safeGetField(inputObj, "mtime");
          if (!maybeNestedObject.IsEmpty() && !maybeNestedObject->IsUndefined() && !maybeNestedObject->IsNull()) {
            auto conversionResult = ConfigurableGitIndexTime::fromJavascript(nodegitContext, maybeNestedObject);
            if (!conversionResult.result) {
              std::string error = "Failed to set mtime: ";
              error += conversionResult.error;
              return {
                error
              };
            }

            auto child = conversionResult.result;
            output->childCleanupVector.push_back(child);
            output->raw->mtime = *child->GetValue();
          }
        }
           {
          v8::Local<v8::Value> maybeNumber = nodegit::safeGetField(inputObj, "dev");
          if (!maybeNumber.IsEmpty() && !maybeNumber->IsUndefined() && !maybeNumber->IsNull()) {
            if (!maybeNumber->IsNumber()) {
              return {
                "Must pass Int32 to dev"
              };
            }

            output->raw->dev = static_cast<uint32_t>(maybeNumber->Int32Value(Nan::GetCurrentContext()).FromJust());
          }
        }
           {
          v8::Local<v8::Value> maybeNumber = nodegit::safeGetField(inputObj, "ino");
          if (!maybeNumber.IsEmpty() && !maybeNumber->IsUndefined() && !maybeNumber->IsNull()) {
            if (!maybeNumber->IsNumber()) {
              return {
                "Must pass Int32 to ino"
              };
            }

            output->raw->ino = static_cast<uint32_t>(maybeNumber->Int32Value(Nan::GetCurrentContext()).FromJust());
          }
        }
           {
          v8::Local<v8::Value> maybeNumber = nodegit::safeGetField(inputObj, "mode");
          if (!maybeNumber.IsEmpty() && !maybeNumber->IsUndefined() && !maybeNumber->IsNull()) {
            if (!maybeNumber->IsNumber()) {
              return {
                "Must pass Int32 to mode"
              };
            }

            output->raw->mode = static_cast<uint32_t>(maybeNumber->Int32Value(Nan::GetCurrentContext()).FromJust());
          }
        }
           {
          v8::Local<v8::Value> maybeNumber = nodegit::safeGetField(inputObj, "uid");
          if (!maybeNumber.IsEmpty() && !maybeNumber->IsUndefined() && !maybeNumber->IsNull()) {
            if (!maybeNumber->IsNumber()) {
              return {
                "Must pass Int32 to uid"
              };
            }

            output->raw->uid = static_cast<uint32_t>(maybeNumber->Int32Value(Nan::GetCurrentContext()).FromJust());
          }
        }
           {
          v8::Local<v8::Value> maybeNumber = nodegit::safeGetField(inputObj, "gid");
          if (!maybeNumber.IsEmpty() && !maybeNumber->IsUndefined() && !maybeNumber->IsNull()) {
            if (!maybeNumber->IsNumber()) {
              return {
                "Must pass Int32 to gid"
              };
            }

            output->raw->gid = static_cast<uint32_t>(maybeNumber->Int32Value(Nan::GetCurrentContext()).FromJust());
          }
        }
           {
          v8::Local<v8::Value> maybeNumber = nodegit::safeGetField(inputObj, "fileSize");
          if (!maybeNumber.IsEmpty() && !maybeNumber->IsUndefined() && !maybeNumber->IsNull()) {
            if (!maybeNumber->IsNumber()) {
              return {
                "Must pass Int32 to fileSize"
              };
            }

            output->raw->file_size = static_cast<uint32_t>(maybeNumber->Int32Value(Nan::GetCurrentContext()).FromJust());
          }
        }
            {
            v8::Local<v8::Value> maybeOid = nodegit::safeGetField(inputObj, "id");
            if (!maybeOid.IsEmpty() && !maybeOid->IsUndefined() && !maybeOid->IsNull()) {
              if (maybeOid->IsString()) {
                Nan::Utf8String oidString(maybeOid.As<v8::String>());
                if (git_oid_fromstr(&output->raw->id, *oidString) != GIT_OK) {
                  return {
                    git_error_last()->message
                  };
                }
              } else if (maybeOid->IsObject()) {
                if (git_oid_cpy(&output->raw->id, Nan::ObjectWrap::Unwrap<GitOid>(maybeOid.As<v8::Object>())->GetValue()) != GIT_OK) {
                  return {
                    git_error_last()->message
                  };
                }
              } else {
                return {
                  "Must pass String or NodeGit.Oid to id"
                };
              }
            }
          }
            {
          v8::Local<v8::Value> maybeNumber = nodegit::safeGetField(inputObj, "flags");
          if (!maybeNumber.IsEmpty() && !maybeNumber->IsUndefined() && !maybeNumber->IsNull()) {
            if (!maybeNumber->IsNumber()) {
              return {
                "Must pass Int32 to flags"
              };
            }

            output->raw->flags = static_cast<uint16_t>(maybeNumber->Int32Value(Nan::GetCurrentContext()).FromJust());
          }
        }
           {
          v8::Local<v8::Value> maybeNumber = nodegit::safeGetField(inputObj, "flagsExtended");
          if (!maybeNumber.IsEmpty() && !maybeNumber->IsUndefined() && !maybeNumber->IsNull()) {
            if (!maybeNumber->IsNumber()) {
              return {
                "Must pass Int32 to flagsExtended"
              };
            }

            output->raw->flags_extended = static_cast<uint16_t>(maybeNumber->Int32Value(Nan::GetCurrentContext()).FromJust());
          }
        }
          output->raw->path = nullptr;
        {
          v8::Local<v8::Value> maybeString = nodegit::safeGetField(inputObj, "path");
          if (!maybeString.IsEmpty() && !maybeString->IsUndefined() && !maybeString->IsNull()) {
            if (!maybeString->IsString()) {
              return {
                "Must pass string to path"
              };
            }

            Nan::Utf8String utf8String(maybeString.As<v8::String>());
            output->raw->path = strdup(*utf8String);
          }
        }
    
  return {
    output
  };
}

                         
// force base class template instantiation, to make sure we get all the
// methods, statics, etc.
template class nodegit::ConfigurableClassWrapper<GitIndexEntryTraits>;
